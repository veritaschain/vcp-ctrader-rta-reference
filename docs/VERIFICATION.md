# VCP Verification Guide

This guide explains how to verify the integrity of VCP audit trails generated by this implementation.

## Overview

VCP provides multiple layers of verification:

1. **Event Hash Verification** - Each event's hash can be independently verified
2. **Merkle Proof Verification** - Prove an event belongs to a batch
3. **Anchor Verification** - Verify external timestamp of Merkle root

## Verification Package

Export a verification package using:

```csharp
await vcp.ExportVerificationPackageAsync("audit_2025Q1");
```

This creates a self-contained directory:

```
audit_2025Q1/
├── events.json          # All events
├── batches.json         # Merkle batches
├── anchors.json         # Anchor records
├── verify.py            # Python verification script
└── README.md            # Verification instructions
```

## Manual Verification

### 1. Event Hash Verification

To verify a single event's hash:

```python
import hashlib
import json

def canonicalize(obj):
    """RFC 8785 simplified JSON canonicalization"""
    return json.dumps(obj, sort_keys=True, separators=(',', ':'))

def verify_event_hash(event):
    # Extract header without EventHash
    header = {k: v for k, v in event['Header'].items() if k != 'EventHash'}
    
    # Get payload (Trade, Governance, Risk, Error)
    payload = {}
    for key in ['Trade', 'Governance', 'Risk', 'Error']:
        if key in event and event[key]:
            payload[key] = event[key]
    
    # Compute hash
    hash_input = canonicalize(header) + canonicalize(payload)
    computed_hash = hashlib.sha256(hash_input.encode()).hexdigest()
    
    return computed_hash == event['Header']['EventHash']
```

### 2. Merkle Proof Verification

To verify an event is included in a Merkle batch:

```python
import hashlib

LEAF_PREFIX = b'\x00'
INTERNAL_PREFIX = b'\x01'

def compute_merkle_hash(data, is_leaf):
    prefix = LEAF_PREFIX if is_leaf else INTERNAL_PREFIX
    return hashlib.sha256(prefix + data).digest()

def verify_inclusion_proof(event_hash, proof, merkle_root):
    # Start with leaf hash
    current = compute_merkle_hash(bytes.fromhex(event_hash), is_leaf=True)
    
    # Walk the audit path
    for step in proof['AuditPath']:
        sibling = bytes.fromhex(step['hash'])
        if step['position'] == 'left':
            combined = sibling + current
        else:
            combined = current + sibling
        current = compute_merkle_hash(combined, is_leaf=False)
    
    return current.hex() == merkle_root.lower()
```

### 3. Anchor Verification

#### Local File Anchor

Local anchors are stored as signed JSON files. Verify the signature matches the Merkle root.

#### OpenTimestamps Anchor

```python
# Install: pip install opentimestamps-client
from opentimestamps.core.timestamp import DetachedTimestampFile
from opentimestamps.core.op import OpSHA256

def verify_ots_anchor(merkle_root, ots_proof):
    """Verify OpenTimestamps proof"""
    # Parse the OTS proof
    timestamp = DetachedTimestampFile.deserialize(bytes.fromhex(ots_proof))
    
    # Verify the digest matches
    digest = bytes.fromhex(merkle_root)
    
    # Verify the timestamp
    # (requires network access to verify against Bitcoin blockchain)
    # See: https://opentimestamps.org/
```

#### FreeTSA (RFC 3161) Anchor

```python
# Verify RFC 3161 timestamp response
from asn1crypto import tsp, cms

def verify_tsa_anchor(merkle_root, tsa_response):
    """Verify RFC 3161 timestamp"""
    response = tsp.TimeStampResp.load(bytes.fromhex(tsa_response))
    
    # Extract message imprint
    token = response['time_stamp_token']
    tst_info = token['content']['encap_content_info']['content'].native
    
    # Verify digest matches
    return tst_info['message_imprint']['hashed_message'].hex() == merkle_root
```

## Automated Verification

The exported `verify.py` script performs all verification automatically:

```bash
cd audit_2025Q1
python verify.py
```

Output:
```
VCP Verification Report
=======================
Total Events: 1,234
Total Batches: 13
Total Anchors: 13

Event Hash Verification:
  ✓ All 1,234 events have valid hashes

Merkle Proof Verification:
  ✓ All events can be proven in their batches

Anchor Verification:
  ✓ 13/13 anchors verified
  - LOCAL_FILE: 13
  - OPENTIMESTAMPS: 0
  - FREE_TSA: 0

Overall: ✓ PASSED
```

## Verification Checklist

### For Auditors

1. **Obtain the verification package** from the system operator
2. **Verify event hashes** to ensure no tampering
3. **Verify Merkle proofs** to confirm batch integrity
4. **Verify anchors** against external sources (blockchain, TSA)
5. **Cross-reference** events with broker records
6. **Check timeline** - events should be chronologically ordered
7. **Verify completeness** - no gaps in event sequence

### For Regulators

1. Request verification packages for specific date ranges
2. Use provided Python scripts for automated verification
3. Cross-reference with broker trade confirmations
4. Verify anchor timestamps against external sources
5. Confirm compliance with VCP Silver Tier requirements

## Common Issues

### Hash Mismatch

If event hashes don't match:
- Check for JSON encoding differences
- Verify timestamp precision
- Ensure no data modification occurred

### Missing Merkle Proof

If a proof is missing:
- Event may not have been batched yet
- Check if batch was interrupted

### Anchor Verification Failed

If anchor verification fails:
- Network access may be required (OpenTimestamps)
- TSA certificate may have expired
- Local anchor file may be corrupted

## Security Notes

1. **Don't trust unverified data** - Always verify before drawing conclusions
2. **Verify anchor sources** - Ensure anchors come from legitimate services
3. **Check for gaps** - Missing events indicate potential tampering
4. **Independent verification** - Use multiple verification methods
5. **Preserve chain of custody** - Document how verification packages were obtained

## API Reference

### VCPMerkleTree.VerifyInclusionProof

```csharp
public static bool VerifyInclusionProof(MerkleInclusionProof proof)
```

Returns `true` if the proof is valid.

### VCPUtility.ComputeEventHash

```csharp
public static string ComputeEventHash(VCPHeader header, object payload)
```

Computes the SHA-256 hash for an event.

## Further Reading

- [VCP Specification v1.1](https://github.com/veritaschain/vcp-specification)
- [RFC 6962 - Certificate Transparency](https://tools.ietf.org/html/rfc6962)
- [RFC 3161 - Time-Stamp Protocol](https://tools.ietf.org/html/rfc3161)
- [OpenTimestamps](https://opentimestamps.org/)
